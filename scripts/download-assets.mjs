import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

const ASSETS_DIR = path.resolve(__dirname, '../src/assets');
const IMAGES_DIR = path.join(ASSETS_DIR, 'images');

const RANKS_DIR = path.join(IMAGES_DIR, 'ranks');
const MAPS_DIR = path.join(IMAGES_DIR, 'maps');

// Ensure directories exist
[RANKS_DIR, MAPS_DIR].forEach(dir => {
    if (!fs.existsSync(dir)) {
        fs.mkdirSync(dir, { recursive: true });
    }
});

async function downloadFile(url, dest) {
    const response = await fetch(url);
    if (!response.ok) throw new Error(`Failed to fetch ${url}`);
    const arrayBuffer = await response.arrayBuffer();
    const buffer = Buffer.from(arrayBuffer);
    fs.writeFileSync(dest, buffer);
    console.log(`Downloaded: ${path.basename(dest)}`);
}

async function fetchRanks() {
    console.log('Fetching Competitive Tiers...');
    const res = await fetch('https://valorant-api.com/v1/competitivetiers');
    const data = await res.json();
    
    // Get the latest episode data (usually the last one in the list)
    const latestTierData = data.data[data.data.length - 1];
    console.log(`Using Tier Data: ${latestTierData.assetObjectName}`);

    const rankMap = {};

    for (const tier of latestTierData.tiers) {
        // Skip unranked if it has no icon, or handle specific tiers
        // Tier 0 is usually Unranked.
        if (tier.largeIcon) {
            const fileName = `tier_${tier.tier}.png`;
            const filePath = path.join(RANKS_DIR, fileName);
            await downloadFile(tier.largeIcon, filePath);
            rankMap[tier.tier] = `./${fileName}`;
        }
    }

    // Generate index.js for easy import
    const indexContent = `// Auto-generated by scripts/download-assets.mjs
${Object.entries(rankMap).map(([id, path]) => `import tier${id} from '${path}';`).join('\n')}

export const rankIcons = {
${Object.keys(rankMap).map(id => `  ${id}: tier${id},`).join('\n')}
};
`;
    fs.writeFileSync(path.join(RANKS_DIR, 'index.js'), indexContent);
    console.log('Generated ranks/index.js');
}

async function fetchMaps() {
    console.log('Fetching Maps...');
    const res = await fetch('https://valorant-api.com/v1/maps');
    const data = await res.json();

    const mapMap = {};

    for (const map of data.data) {
        // Use listViewIcon or splash. splash is wide, listViewIcon is tall/square usually.
        // The project was using /maps/ascent.jpg (likely splashes or list views).
        // Let's download list view (Tall) and Splash (Wide).
        // For now, let's grab the 'splash' as usage implies background images often, 
        // but 'list view' is better for cards.
        // User code: `/maps/ascent.jpg` in match list -> likely List View or Splash.
        // Let's stick to 'splash' for hero/bg and check 'listViewIcon' for cards.
        // To be safe, I'll download 'splash' as the primary map image.
        
        const mapName = map.displayName.toLowerCase().replace(/[^a-z0-9]/g, '');
        if (map.splash) {
            const fileName = `${mapName}.png`;
            const filePath = path.join(MAPS_DIR, fileName);
            await downloadFile(map.splash, filePath);
            mapMap[map.displayName] = `./${fileName}`;
        }
    }

    // Generate index.js
    const indexContent = `// Auto-generated by scripts/download-assets.mjs
${Object.entries(mapMap).map(([name, path]) => {
    const safeName = name.replace(/[^a-zA-Z0-9]/g, '');
    return `import ${safeName} from '${path}';`;
}).join('\n')}

export const mapImages = {
${Object.entries(mapMap).map(([name]) => {
    const safeName = name.replace(/[^a-zA-Z0-9]/g, '');
    return `  "${name}": ${safeName},`;
}).join('\n')}
};
`;
    fs.writeFileSync(path.join(MAPS_DIR, 'index.js'), indexContent);
    console.log('Generated maps/index.js');
}

async function fetchAgents() {
    console.log('Fetching Agents...');
    const res = await fetch('https://valorant-api.com/v1/agents?isPlayableCharacter=true');
    const data = await res.json();
    const agentsDir = path.join(IMAGES_DIR, 'agents');
    
    if (!fs.existsSync(agentsDir)) {
        fs.mkdirSync(agentsDir, { recursive: true });
    }

    const agentMap = {};

    for (const agent of data.data) {
        const agentName = agent.displayName.replace(/[^a-zA-Z0-9]/g, '');
        const fileName = `${agentName}.png`;
        const filePath = path.join(agentsDir, fileName);
        await downloadFile(agent.displayIcon, filePath);
        agentMap[agent.displayName] = `./${fileName}`;
    }

    // Generate index.js
    const indexContent = `// Auto-generated by scripts/download-assets.mjs
${Object.entries(agentMap).map(([name, path]) => {
    const safeName = name.replace(/[^a-zA-Z0-9]/g, '');
    return `import ${safeName} from '${path}';`;
}).join('\n')}

export const agentIcons = {
${Object.entries(agentMap).map(([name]) => {
    const safeName = name.replace(/[^a-zA-Z0-9]/g, '');
    return `  "${name}": ${safeName},`;
}).join('\n')}
};
`;
    fs.writeFileSync(path.join(agentsDir, 'index.js'), indexContent);
    console.log('Generated agents/index.js');
}

async function main() {
    try {
        await fetchRanks();
        await fetchMaps();
        await fetchAgents();
        console.log('Asset download complete!');
    } catch (error) {
        console.error('Error downloading assets:', error);
        process.exit(1);
    }
}

main();
